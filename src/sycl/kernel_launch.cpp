// File: src/sycl/kernel_launch.cpp

#include <CL/sycl.hpp>
#include <oneapi/mkl.hpp>
#include <iostream>
#include <vector>
#include <chrono>
#include <cmath>
#include <cstdlib>

#include "src/base.h"        // parseCmdLineArgs, readMTXdense, etc.
#include "src/sycl/base.h"   // syclAllocDouble, syclCopyToDevice, syclCopyToHost, etc.

// The GiMMiK kernel is declared as an extern symbol so the linker knows about it.
// The actual definition (the SYCL kernel) is in, e.g., "kernels/gimmik/sycl/p3/hex/M0_bstream_sycl.cpp"
// after being generated by our python script.
extern void gimmik_mm(sycl::queue &q, const double* b, double* c);

/**
 * \brief Parse the kernel path, e.g. "kernels/gimmik/sycl/p3/hex/M0_bstream.cpp"
 *        to build a matching .mtx path => "operators/p3/hex/M0.mtx".
 *        This replicates the logic from the CUDA version.
 */
static std::string kernelToMtxPath(const std::string &kernelPath, FileMetadata &meta)
{
    // Example: kernelPath = "kernels/gimmik/sycl/p3/hex/M0_bstream.cpp"
    // 1) Find "kernels/gimmik/p"
    size_t pos = kernelPath.find("kernels/gimmik/p");
    if (pos == std::string::npos) {
        return "";
    }
    pos += std::string("kernels/gimmik/").size();

    // Next char => polynomial order
    pos++; 
    meta.order = kernelPath.substr(pos, 1);

    // Next slash => e.g. "...p3/hex..."
    size_t slashPos = kernelPath.find('/', pos);
    meta.etype = kernelPath.substr(slashPos + 1, 3);

    // final filename => e.g. "M0_bstream.cpp"
    std::string fname = kernelPath.substr(kernelPath.find_last_of('/') + 1);
    // remove ".cpp"
    size_t dotPos = fname.rfind(".cpp");
    std::string baseName = (dotPos != std::string::npos)
                           ? fname.substr(0, dotPos)
                           : fname;

    // e.g. baseName = "M0_bstream"
    // Split into AMatName="M0", backend="bstream"? 
    // We'll do the same approach as your CUDA code. 
    meta.AMatName = baseName.substr(0, baseName.find('_'));
    meta.backend  = baseName.substr(baseName.find('_') + 1,
                                    baseName.rfind('_') - baseName.find('_') - 1);
    meta.mmtype   = baseName.substr(baseName.rfind('_') + 1);

    // prefix mmtype with "gimmik_"
    meta.mmtype = "gimmik_" + meta.mmtype;

    // Build .mtx => "operators/p3/hex/M0.mtx"
    std::string mtxPath = "operators/p" + meta.order + "/" + meta.etype
                          + "/" + meta.AMatName + ".mtx";
    return mtxPath;
}

int main(int argc, char* argv[])
{
    // 1) Parse command line: usage <device> <kernelPath> <n> <niters>
    if (argc < 5) {
        std::cerr << "Usage: " << argv[0]
                  << " <device> <kernelPath> <n> <niters>\n";
        return 1;
    }

    CmdLineArgs args;
    args.device     = argv[1];          // e.g. "max1550"
    std::string kernelPath = argv[2];   // e.g. "kernels/gimmik/sycl/p3/hex/M0_bstream.cpp"
    args.n          = static_cast<size_t>(atoi(argv[3]));
    args.niters     = atoi(argv[4]);

    // 2) Derive .mtx path => parse metadata
    FileMetadata meta;
    std::string mtxPath = kernelToMtxPath(kernelPath, meta);
    meta.device = args.device;
    if (mtxPath.empty()) {
        std::cerr << "Error: unable to derive .mtx from kernel path: " << kernelPath << "\n";
        return 1;
    }

    // 3) Read matrix => we only need (m, k)
    //    store A_data in col-major or row-major, as you prefer. 
    //    Let's say your readMTXdense is column-major by default:
    std::vector<double> A_data;
    size_t m, k;
    readMTXdense(mtxPath, A_data, m, k, meta);

    // 4) Prepare B, C on host
    //    B => (k x n) all ones
    //    C => (m x n) zeros
    //    If you're using row-major for your kernel, set ldb = n, etc.
    std::vector<double> B_host(k * args.n, 1.0);
    std::vector<double> C_host(m * args.n, 0.0);

    // 5) Create a SYCL queue (we're ignoring device name or your 'args.device' for now)
    sycl::queue q(sycl::gpu_selector_v);

    // 6) Allocate device memory
    double* dB = syclAllocDouble(q, B_host.size());
    double* dC = syclAllocDouble(q, C_host.size());

    syclCopyToDevice(q, dB, B_host);
    syclCopyToDevice(q, dC, C_host);

    // 7) Warm-up kernel call
    //    We'll interpret row-major => ldb=n, ldc=n. 
    int ldb = (int)args.n;
    int ldc = (int)args.n;

    // Call the SYCL kernel "gimmik_mm(q, n, dB, ldb, dC, ldc);"
    gimmik_mm(q, dB, dC);
    q.wait();

    // 8) Correctness check vs. oneMKL
    //    We'll do a reference gemm => dR = A * B => compare vs. dC
    //    Suppose readMTXdense was col-major => A is (m x k) with ldA=m
    {
        double* dA = syclAllocDouble(q, A_data.size());
        syclCopyToDevice(q, dA, A_data);

        double* dR = syclAllocDouble(q, C_host.size());
        q.memset(dR, 0, C_host.size() * sizeof(double));

        double alpha = 1.0, beta = 0.0;
        // oneMKL col-major gemm => A is (m x k), B is (k x n), C is (m x n)
        // leading dims => A: ldA=m, B: ldB=k, R: ldC=m
        // but if you're actually row-major in the kernel, you have to be consistent. 
        // We'll assume col-major for the reference since A_data is col-major by default.
        try {
            oneapi::mkl::blas::column_major::gemm(
                q,
                oneapi::mkl::transpose::nontrans,
                oneapi::mkl::transpose::nontrans,
                (int)m, (int)args.n, (int)k,
                alpha,
                dA, (int)m,
                dB, (int)k,
                beta,
                dR, (int)m
            );
            q.wait();
        } catch (sycl::exception const &e) {
            std::cerr << "Reference dense gemm failed: " << e.what() << "\n";
            return 1;
        }

        // Compare dC vs. dR
        bool match = true;
        std::vector<double> hostC(C_host.size()), hostR(C_host.size());
        q.memcpy(hostC.data(), dC, hostC.size() * sizeof(double)).wait();
        q.memcpy(hostR.data(), dR, hostR.size() * sizeof(double)).wait();

        for (size_t i = 0; i < hostC.size(); i++) {
            double diff = std::fabs(hostC[i] - hostR[i]);
            if (diff > 1e-6) {
                match = false;
                break;
            }
        }
        if (!match) {
            std::cerr << "[Warm-up] GiMMiK kernel results do not match reference.\n";
            return 1;
        }

        syclFreeDouble(q, dA);
        syclFreeDouble(q, dR);
    }

    // 9) Timed loop
    auto start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < args.niters; i++) {
        gimmik_mm(q, dB, dC);
    }
    q.wait();
    auto end = std::chrono::high_resolution_clock::now();
    double avg_sec = std::chrono::duration<double>(end - start).count() / args.niters;

    // 10) Write CSV
    writeOutputCSV(meta, args.n, avg_sec, efficiency(meta, m, k, args.n, avg_sec));

    // 11) Cleanup
    syclFreeDouble(q, dB);
    syclFreeDouble(q, dC);

    return 0;
}
